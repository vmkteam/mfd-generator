# Генератор dbtest

Генератор, предназначенный для генерации вспомогательных функций тестирования базы данных из описания MFD.
Этот инструмент создает или обновляет функции для вставки тестовых данных по неймспейсам и сущностям.

## Возможности

- **Автоматическая генерация тестовых функций**: Создаёт вспомогательные функции для вставки данных в таблицы.  
- **Автоматическая генерация опциональных функций**: Создаёт опциональные функции для заполнения необходимых полей 
рандомными данными, для предварительного создания реляций, необходимых для вставки сущности.  
- **Выборочная генерация**: Поддерживает генерацию функций для определённых нейспейсов и сущностей.
- **Принудительная регенерация**: Опция для принудительной регенерации существующих функций.  

## Использование

Сначала необходимо сгенерировать основу проекта с помощью [xml генератора](../xml/README.md), [генератора моделей](../model/README.md)
и [генератора репозиториев](../repo/README.md).

После этого генератор `dbtest` прочитает аннотации нейспейсов и сущностей из xml-файла и сгенерирует хелперы для db-тестов.

### Интерфейс командной строки

Для генерации перейдите в директорию Вашего проекта. Базовый пример команды с необходимыми ключами:
```bash
# Базовое использование
dbtest -x 'newsportal/pkg/db' -o './pkg/db/test' -m './docs/model/uteka.mfd'
```
### Обязательные флаги

- `-x, --db-pkg`: Пакет, содержащий файлы базы данных, сгенерированные с помощью генератора моделей.
Нужно указать так же, как он выглядит в блоке `import`.
- `-o, --output`: путь, куда положить сгенерированные файлы.
- `-m, --mfd`: путь, где лежит `.mfd` файл проекта

### Необязательные флаги

- `-n, --namespaces` - генерация только для указанных неймспейсов (по аналогии с [генератором репозиториев](../repo/README.md)).
Пример: `-n portal,geo`.
- `-e, --entities` - генерация только для указанных сущностей (по аналогии с [генератором vt](../vt/README.md))
Пример: `-e news,categories`.
- `-f, --force` - принудительная перегенерация. Если указан этот флаг, то при повторной генерации заменит существующий контент.
Если передан `-f` без `-n` и `-e`, заменит все существующие файлы на новые.
Если передан `-f` в сочетании хотя бы с `-n` или `-e`, то найдёт все переданные сущности или вычислит их для переданных
нейспейсов и заменит контент только для них. 

### Примеры:

```bash
# Генерация для конкретных неймспейсов
dbtest -x 'newsportal/pkg/db' -o './pkg/db/test' -m './docs/model/uteka.mfd' -n portal,geo

# Генерация для конкретных сущностей
dbtest-x 'newsportal/pkg/db' -o './pkg/db/test' -m './docs/model/uteka.mfd' news,categories

# Принудительная перегенерация
dbtest -x 'newsportal/pkg/db' -o './pkg/db/test' -m './docs/model/uteka.mfd' -f

# Принудительная регенерация только сущности News
dbtest -x 'newsportal/pkg/db' -o './pkg/db/test' -m './docs/model/uteka.mfd' -e news -f
```

## Сгенерированный результат

Генератор создаёт:

1. **Файл Setup** (`test.go`): Базовые утилиты тестирования и функции инициализации  
2. **Файлы по неймспейсам**: Отдельные Go-файлы для каждого неймспейса, содержащие:  
   - Основные функции вставки тестовых данных,
   - Тип OpFunc для дополнительных функций,
   - Дополнительные функции с поддержкой вставки всех вложенных реляций,
   - Дополнительные функции с генерацией рандомных данных для обязательных полей.  

## Пример сгенерированной функции

```go
// NewsOpFunc Тип дополнительных функций
type NewsOpFunc func(t *testing.T, dbo orm.DB, in *db.News) Cleaner

// News Основной хелпер для вставки новости
func News(t *testing.T, dbo orm.DB, in *db.News, ops ...NewsOpFunc) (*db.News, Cleaner) {
    // Generated insertion logic
}

// WithNewsRelations Дополнительная функция для передачи в News.
// Помогает вставить все необходимые реляции для News перед непосредственной вставкой самой новости.
// Нужно, если нам не важно, какие именно будут реляции, и вызывающий не хочет об этом думать.
// Если вызывающий хочет строго контролировать поведение реляций, можно не передавать в вызов News
func WithNewsRelations(t *testing.T, dbo orm.DB, in *db.News) Cleaner {
    // Generated insertion with related entities
}

// WithFakeNews Дополнительная функция для передачи в News.
// Генерирует рандомные данные для обязательных полей перед непосредственной вставкой самой новости.
// Нужно, если нам не важно, какие именно будут данные, но нужны хоть какие-нибудь и мы не хотим это делать руками.
// Если вызывающий хочет строго контролировать поведение данных, можно не передавать в вызов News
func WithFakeNews(t *testing.T, dbo orm.DB, in *db.News) Cleaner {
    // Generated insertion with fake data
}
```

## Пример использования сгенерированных функций

```go
   // Простая вставка тега
   func Test_test(t *testing.T) {
       dbo := test.Setup(t)
   
       res, clean := test.Tag(t, dbo, nil)
       defer clean()
   
       fmt.Println(res)
   }

   // Простая вставка новости с указанным тегом и категорией
   func Test_test(t *testing.T) {
       dbo := test.Setup(t)
   
       tag, clean := test.Tag(t, dbo, nil)
       defer clean()
       c, clean := test.Category(t, dbo, nil)
       defer clean()
       news, clean := test.News(t, dbo, &db.News{CategoryID: c.ID, TagIDs: []int{tag.ID}})
       defer clean()
   
       fmt.Println(news)
   }

   // Вставка новости с рандомными реляциями и сгенерерированными обязательными полями
   func Test_test(t *testing.T) {
       dbo := test.Setup(t)
   
       news, clean := test.News(t, dbo, nil, WithNewsRelations, WithFakeNews)
       defer clean()
   
       fmt.Println(news)
   }

    // Вставка 100 новостей в одной категории
   func Test_test(t *testing.T) {
       dbo := test.Setup(t)
   
       news, clean := test.News(t, dbo, nil, WithNewsRelations, WithFakeNews)
       defer clean()
       
       for i := 0; i < 99; i++ {
           _, clean := test.News(t, dbo, &db.News{
              CategoryID: news.CategoryID,
           }, WithNewsRelations, WithFakeNews)
           defer clean()
       }
   }
```

## Примечания

Если в БД уже есть требуемая сущность, и нужно получить её по PKs, достаточно вызвать:

```go
   // Простая вставка тега
   func Test_test(t *testing.T) {
       dbo := test.Setup(t)
   
       news, clean := test.News(t, dbo, &db.News{ID: 10})
       defer clean()
   
       fmt.Println(news)
   }
```

Когда передан PK, всегда будет попытка найти по нему нужную сущность.

**Важный момент!** Если все PK имеют свойство в БД `not null`,
и не имеют свойства в БД `default` (т.е., при передаче пустого значения не предусмотрено значение по умолчанию),
в этом случае если сущность не найдена, будет предпринята попытка **вставить** новую сущность
со значениями PKs, которые были переданы в ней.

Такое поведение нужно, когда мы хотим вставить строки для таблиц, которые имеют простой или составной PK,
который `not null` в БД, и для которого не предусмотрено значение по умолчанию в самой БД.

Например, есть какая-нибудь таблица цен с составным PK без значений по умолчанию:

```sql
create table prices (
    "partnerId" text not null,
    "productId" text not null,
    title text,
    constraint pk_prices
       primary key ("partnerId", "productId")
)
```

Для того, чтобы вставить данные в такуюб таблицу, необходимо обязательно указать `partnerId` и `productId`.

Поэтому для таких случаев есть поддержка вставки новых строк по переданным PKs,
если они не были заданы.

В других случаях, например, для новости:

```sql
CREATE TABLE "news" (
   "newsId" SERIAL NOT NULL,
   "title" varchar(255) NOT NULL,
   "content" text,
   "categoryId" int4 NOT NULL,
   "tagIds" int4[],
   "createdAt" timestamp with time zone NOT NULL DEFAULT NOW(),
   "publishedAt" timestamp with time zone,
   "statusId" int4 NOT NULL,
   PRIMARY KEY("newsId")
);
```

PK - это `newsId`, который так же имеет свойство `not null`, но при этом у него есть значение по умолчанию.

Для таких случаев, если сущность не найдена по переданному PK, тест завершится с ошибкой.
