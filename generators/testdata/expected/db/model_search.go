// Code generated by mfd-generator unknown; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type CategorySearch struct {
	search

	ID          *int
	Title       *string
	OrderNumber *int
	StatusID    *int
	IDs         []int
	TitleILike  *string
}

func (cs *CategorySearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.ID, cs.ID)
	}
	if cs.Title != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.Title, cs.Title)
	}
	if cs.OrderNumber != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.OrderNumber, cs.OrderNumber)
	}
	if cs.StatusID != nil {
		cs.where(query, Tables.Category.Alias, Columns.Category.StatusID, cs.StatusID)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.Category.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.TitleILike != nil {
		Filter{Columns.Category.Title, *cs.TitleILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CategorySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type NewsSearch struct {
	search

	ID           *int
	Title        *string
	Preview      *string
	Content      *string
	CategoryID   *int
	CountryID    *int
	RegionID     *int
	CityID       *int
	CreatedAt    *time.Time
	PublishedAt  *time.Time
	StatusID     *int
	IDs          []int
	TitleILike   *string
	PreviewILike *string
	ContentILike *string
}

func (ns *NewsSearch) Apply(query *orm.Query) *orm.Query {
	if ns == nil {
		return query
	}
	if ns.ID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.ID, ns.ID)
	}
	if ns.Title != nil {
		ns.where(query, Tables.News.Alias, Columns.News.Title, ns.Title)
	}
	if ns.Preview != nil {
		ns.where(query, Tables.News.Alias, Columns.News.Preview, ns.Preview)
	}
	if ns.Content != nil {
		ns.where(query, Tables.News.Alias, Columns.News.Content, ns.Content)
	}
	if ns.CategoryID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.CategoryID, ns.CategoryID)
	}
	if ns.CountryID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.CountryID, ns.CountryID)
	}
	if ns.RegionID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.RegionID, ns.RegionID)
	}
	if ns.CityID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.CityID, ns.CityID)
	}
	if ns.CreatedAt != nil {
		ns.where(query, Tables.News.Alias, Columns.News.CreatedAt, ns.CreatedAt)
	}
	if ns.PublishedAt != nil {
		ns.where(query, Tables.News.Alias, Columns.News.PublishedAt, ns.PublishedAt)
	}
	if ns.StatusID != nil {
		ns.where(query, Tables.News.Alias, Columns.News.StatusID, ns.StatusID)
	}
	if len(ns.IDs) > 0 {
		Filter{Columns.News.ID, ns.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ns.TitleILike != nil {
		Filter{Columns.News.Title, *ns.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if ns.PreviewILike != nil {
		Filter{Columns.News.Preview, *ns.PreviewILike, SearchTypeILike, false}.Apply(query)
	}
	if ns.ContentILike != nil {
		Filter{Columns.News.Content, *ns.ContentILike, SearchTypeILike, false}.Apply(query)
	}

	ns.apply(query)

	return query
}

func (ns *NewsSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ns == nil {
			return query, nil
		}
		return ns.Apply(query), nil
	}
}

type TagSearch struct {
	search

	ID         *int
	Title      *string
	StatusID   *int
	IDs        []int
	TitleILike *string
}

func (ts *TagSearch) Apply(query *orm.Query) *orm.Query {
	if ts == nil {
		return query
	}
	if ts.ID != nil {
		ts.where(query, Tables.Tag.Alias, Columns.Tag.ID, ts.ID)
	}
	if ts.Title != nil {
		ts.where(query, Tables.Tag.Alias, Columns.Tag.Title, ts.Title)
	}
	if ts.StatusID != nil {
		ts.where(query, Tables.Tag.Alias, Columns.Tag.StatusID, ts.StatusID)
	}
	if len(ts.IDs) > 0 {
		Filter{Columns.Tag.ID, ts.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ts.TitleILike != nil {
		Filter{Columns.Tag.Title, *ts.TitleILike, SearchTypeILike, false}.Apply(query)
	}

	ts.apply(query)

	return query
}

func (ts *TagSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ts == nil {
			return query, nil
		}
		return ts.Apply(query), nil
	}
}

type CitySearch struct {
	search

	ID            *int
	RegionID      *int
	CountryID     *int
	Title         *string
	AltTitle      *string
	Alias         *string
	OrderNumber   *int
	StatusID      *int
	IDs           []int
	NotID         *int
	TitleILike    *string
	AltTitleILike *string
}

func (cs *CitySearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.City.Alias, Columns.City.ID, cs.ID)
	}
	if cs.RegionID != nil {
		cs.where(query, Tables.City.Alias, Columns.City.RegionID, cs.RegionID)
	}
	if cs.CountryID != nil {
		cs.where(query, Tables.City.Alias, Columns.City.CountryID, cs.CountryID)
	}
	if cs.Title != nil {
		cs.where(query, Tables.City.Alias, Columns.City.Title, cs.Title)
	}
	if cs.AltTitle != nil {
		cs.where(query, Tables.City.Alias, Columns.City.AltTitle, cs.AltTitle)
	}
	if cs.Alias != nil {
		cs.where(query, Tables.City.Alias, Columns.City.Alias, cs.Alias)
	}
	if cs.OrderNumber != nil {
		cs.where(query, Tables.City.Alias, Columns.City.OrderNumber, cs.OrderNumber)
	}
	if cs.StatusID != nil {
		cs.where(query, Tables.City.Alias, Columns.City.StatusID, cs.StatusID)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.City.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.NotID != nil {
		Filter{Columns.City.ID, *cs.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if cs.TitleILike != nil {
		Filter{Columns.City.Title, *cs.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.AltTitleILike != nil {
		Filter{Columns.City.AltTitle, *cs.AltTitleILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CitySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type CountrySearch struct {
	search

	ID                   *int
	Title                *string
	AltTitle             *string
	Alias                *string
	OrderNumber          *int
	H1                   *string
	PageTitle            *string
	MetaDescription      *string
	StatusID             *int
	IDs                  []int
	NotID                *int
	TitleILike           *string
	AltTitleILike        *string
	H1ILike              *string
	PageTitleILike       *string
	MetaDescriptionILike *string
}

func (cs *CountrySearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.ID, cs.ID)
	}
	if cs.Title != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.Title, cs.Title)
	}
	if cs.AltTitle != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.AltTitle, cs.AltTitle)
	}
	if cs.Alias != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.Alias, cs.Alias)
	}
	if cs.OrderNumber != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.OrderNumber, cs.OrderNumber)
	}
	if cs.H1 != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.H1, cs.H1)
	}
	if cs.PageTitle != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.PageTitle, cs.PageTitle)
	}
	if cs.MetaDescription != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.MetaDescription, cs.MetaDescription)
	}
	if cs.StatusID != nil {
		cs.where(query, Tables.Country.Alias, Columns.Country.StatusID, cs.StatusID)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.Country.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.NotID != nil {
		Filter{Columns.Country.ID, *cs.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if cs.TitleILike != nil {
		Filter{Columns.Country.Title, *cs.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.AltTitleILike != nil {
		Filter{Columns.Country.AltTitle, *cs.AltTitleILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.H1ILike != nil {
		Filter{Columns.Country.H1, *cs.H1ILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.PageTitleILike != nil {
		Filter{Columns.Country.PageTitle, *cs.PageTitleILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.MetaDescriptionILike != nil {
		Filter{Columns.Country.MetaDescription, *cs.MetaDescriptionILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CountrySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type RegionSearch struct {
	search

	ID                   *int
	CountryID            *int
	Title                *string
	AltTitle             *string
	Alias                *string
	OrderNumber          *int
	Image                *string
	H1                   *string
	PageTitle            *string
	MetaDescription      *string
	StatusID             *int
	IDs                  []int
	NotID                *int
	TitleILike           *string
	AltTitleILike        *string
	ImageILike           *string
	H1ILike              *string
	PageTitleILike       *string
	MetaDescriptionILike *string
}

func (rs *RegionSearch) Apply(query *orm.Query) *orm.Query {
	if rs == nil {
		return query
	}
	if rs.ID != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.ID, rs.ID)
	}
	if rs.CountryID != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.CountryID, rs.CountryID)
	}
	if rs.Title != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.Title, rs.Title)
	}
	if rs.AltTitle != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.AltTitle, rs.AltTitle)
	}
	if rs.Alias != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.Alias, rs.Alias)
	}
	if rs.OrderNumber != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.OrderNumber, rs.OrderNumber)
	}
	if rs.Image != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.Image, rs.Image)
	}
	if rs.H1 != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.H1, rs.H1)
	}
	if rs.PageTitle != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.PageTitle, rs.PageTitle)
	}
	if rs.MetaDescription != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.MetaDescription, rs.MetaDescription)
	}
	if rs.StatusID != nil {
		rs.where(query, Tables.Region.Alias, Columns.Region.StatusID, rs.StatusID)
	}
	if len(rs.IDs) > 0 {
		Filter{Columns.Region.ID, rs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if rs.NotID != nil {
		Filter{Columns.Region.ID, *rs.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if rs.TitleILike != nil {
		Filter{Columns.Region.Title, *rs.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.AltTitleILike != nil {
		Filter{Columns.Region.AltTitle, *rs.AltTitleILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.ImageILike != nil {
		Filter{Columns.Region.Image, *rs.ImageILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.H1ILike != nil {
		Filter{Columns.Region.H1, *rs.H1ILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.PageTitleILike != nil {
		Filter{Columns.Region.PageTitle, *rs.PageTitleILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.MetaDescriptionILike != nil {
		Filter{Columns.Region.MetaDescription, *rs.MetaDescriptionILike, SearchTypeILike, false}.Apply(query)
	}

	rs.apply(query)

	return query
}

func (rs *RegionSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if rs == nil {
			return query, nil
		}
		return rs.Apply(query), nil
	}
}

type VfsFileSearch struct {
	search

	ID            *int
	FolderID      *int
	Title         *string
	Path          *string
	Params        *string
	IsFavorite    *bool
	MimeType      *string
	FileSize      *int
	FileExists    *bool
	CreatedAt     *time.Time
	StatusID      *int
	IDs           []int
	TitleILike    *string
	PathILike     *string
	ParamsILike   *string
	MimeTypeILike *string
}

func (vfs *VfsFileSearch) Apply(query *orm.Query) *orm.Query {
	if vfs == nil {
		return query
	}
	if vfs.ID != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.ID, vfs.ID)
	}
	if vfs.FolderID != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.FolderID, vfs.FolderID)
	}
	if vfs.Title != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.Title, vfs.Title)
	}
	if vfs.Path != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.Path, vfs.Path)
	}
	if vfs.Params != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.Params, vfs.Params)
	}
	if vfs.IsFavorite != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.IsFavorite, vfs.IsFavorite)
	}
	if vfs.MimeType != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.MimeType, vfs.MimeType)
	}
	if vfs.FileSize != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.FileSize, vfs.FileSize)
	}
	if vfs.FileExists != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.FileExists, vfs.FileExists)
	}
	if vfs.CreatedAt != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.CreatedAt, vfs.CreatedAt)
	}
	if vfs.StatusID != nil {
		vfs.where(query, Tables.VfsFile.Alias, Columns.VfsFile.StatusID, vfs.StatusID)
	}
	if len(vfs.IDs) > 0 {
		Filter{Columns.VfsFile.ID, vfs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if vfs.TitleILike != nil {
		Filter{Columns.VfsFile.Title, *vfs.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if vfs.PathILike != nil {
		Filter{Columns.VfsFile.Path, *vfs.PathILike, SearchTypeILike, false}.Apply(query)
	}
	if vfs.ParamsILike != nil {
		Filter{Columns.VfsFile.Params, *vfs.ParamsILike, SearchTypeILike, false}.Apply(query)
	}
	if vfs.MimeTypeILike != nil {
		Filter{Columns.VfsFile.MimeType, *vfs.MimeTypeILike, SearchTypeILike, false}.Apply(query)
	}

	vfs.apply(query)

	return query
}

func (vfs *VfsFileSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if vfs == nil {
			return query, nil
		}
		return vfs.Apply(query), nil
	}
}

type VfsFolderSearch struct {
	search

	ID             *int
	ParentFolderID *int
	Title          *string
	IsFavorite     *bool
	CreatedAt      *time.Time
	StatusID       *int
	IDs            []int
	TitleILike     *string
}

func (vfs *VfsFolderSearch) Apply(query *orm.Query) *orm.Query {
	if vfs == nil {
		return query
	}
	if vfs.ID != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.ID, vfs.ID)
	}
	if vfs.ParentFolderID != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.ParentFolderID, vfs.ParentFolderID)
	}
	if vfs.Title != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.Title, vfs.Title)
	}
	if vfs.IsFavorite != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.IsFavorite, vfs.IsFavorite)
	}
	if vfs.CreatedAt != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.CreatedAt, vfs.CreatedAt)
	}
	if vfs.StatusID != nil {
		vfs.where(query, Tables.VfsFolder.Alias, Columns.VfsFolder.StatusID, vfs.StatusID)
	}
	if len(vfs.IDs) > 0 {
		Filter{Columns.VfsFolder.ID, vfs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if vfs.TitleILike != nil {
		Filter{Columns.VfsFolder.Title, *vfs.TitleILike, SearchTypeILike, false}.Apply(query)
	}

	vfs.apply(query)

	return query
}

func (vfs *VfsFolderSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if vfs == nil {
			return query, nil
		}
		return vfs.Apply(query), nil
	}
}
